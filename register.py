import discord
from discord.ext import commands
from logs import Logs
from discord.ui import Button, View, Modal, TextInput
import re
import sqlite3
import math
import datetime
from xp import xp_for_next_level

conn = sqlite3.connect('characters.db', check_same_thread=False)
c = conn.cursor()

def apply_layout(user_id, title, description):
    c.execute("SELECT title_layout, description_layout FROM layout_settings WHERE user_id=?", (user_id,))
    layout = c.fetchone()

    if layout:
        title_layout, description_layout = layout
    else:
        title_layout = "‚ïö **‚ïö‚ïê‚ïê‚ïê‚îÅ‚ïê‚îÄ ‚ú¶ ‚îÄ‚ïê‚îÅ‚ïê‚ïê‚ïê‚ïó**\n**‚ïö‚ï° ‚¨• {title} ‚¨• ‚ïû**"
        description_layout = "‚ïö‚îÄ‚îÄ‚îÄ‚ñ∫ *„Äå{description}„Äç*"

    formatted_title = title_layout.replace("{title}", title)
    formatted_description = description_layout.replace("{description}", description)

    return formatted_title, formatted_description


def to_bold_sans_serif(text):
    bold_sans_serif = {
        'A': 'ùêÄ', 'B': 'ùêÅ', 'C': 'ùêÇ', 'D': 'ùêÉ', 'E': 'ùêÑ', 'F': 'ùêÖ', 'G': 'ùêÜ',
        'H': 'ùêá', 'I': 'ùêà', 'J': 'ùêâ', 'K': 'ùêä', 'L': 'ùêã', 'M': 'ùêå', 'N': 'ùêç',
        'O': 'ùêé', 'P': 'ùêè', 'Q': 'ùêê', 'R': 'ùêë', 'S': 'ùêí', 'T': 'ùêì', 'U': 'ùêî',
        'V': 'ùêï', 'W': 'ùêñ', 'X': 'ùêó', 'Y': 'ùêò', 'Z': 'ùêô',
        'a': 'ùêö', 'b': 'ùêõ', 'c': 'ùêú', 'd': 'ùêù', 'e': 'ùêû', 'f': 'ùêü', 'g': 'ùê†',
        'h': 'ùê°', 'i': 'ùê¢', 'j': 'ùê£', 'k': 'ùê§', 'l': 'ùê•', 'm': 'ùê¶', 'n': 'ùêß',
        'o': 'ùê®', 'p': 'ùê©', 'q': 'ùê™', 'r': 'ùê´', 's': 'ùê¨', 't': 'ùê≠', 'u': 'ùêÆ',
        'v': 'ùêØ', 'w': 'ùê∞', 'x': 'ùê±', 'y': 'ùê≤', 'z': 'ùê≥'
    }
    return ''.join(bold_sans_serif.get(c, c) for c in text.upper())

def parse_registration_args(args):
    pattern = r'\'(.*?)\'|(\S+)'
    matches = re.findall(pattern, args)
    tokens = [match[0] if match[0] else match[1] for match in matches]

    name = tokens[0] if len(tokens) > 0 else None
    return name

async def send_embed(ctx, title, description, color=discord.Color.blue(), image_url=None):
    embed = discord.Embed(title=title, description=description, color=color)
    if image_url:
        embed.set_image(url=image_url)
    await ctx.send(embed=embed)

def register_commands(bot):
    @bot.command(name='register')
    async def register(ctx, *, args: str):
        name = parse_registration_args(args)
        if not name:
            await send_embed(ctx, "**__```ùêÖùêéùêëùêåùêÄùêìùêé ùêàùêçùêïùêÄÃÅùêãùêàùêÉùêé```__**", "- > **Use: kill!register 'Nome'**", discord.Color.red())
            return

        c.execute("SELECT 1 FROM characters WHERE name COLLATE NOCASE=? AND user_id=?", (name, ctx.author.id))
        if c.fetchone():
            await send_embed(ctx, "**__```ùêçùêéùêåùêÑ ùêÑùêå ùêîùêíùêé```__**", "- > **Voc√™ j√° tem um personagem com esse nome.**", discord.Color.red())
            return

        image_url = ctx.message.attachments[0].url if ctx.message.attachments else None
        registered_at = datetime.datetime.now().strftime("%Y-%m-%d")
        message_id = ctx.message.id if ctx.message.attachments else None

        c.execute(
            "INSERT INTO characters (name, image_url, user_id, registered_at, message_id) VALUES (?, ?, ?, ?, ?)",
            (name, image_url, ctx.author.id, registered_at, message_id)
        )
        conn.commit()
        await send_embed(ctx, "**__```ùêèùêÑùêëùêíùêéùêçùêÄùêÜùêÑùêå ùêëùêÑùêÜùêàùêíùêìùêëùêÄùêÉùêé!!!```__**",
                         f'- > **Personagem __{name}__ registrado com sucesso!**',
                         discord.Color.green(), image_url)

    @bot.command(name='remove')
    async def remove(ctx, *, name: str):
        c.execute("DELETE FROM characters WHERE name COLLATE NOCASE=? AND user_id=?", (name, ctx.author.id))
        if c.rowcount == 0:
            await send_embed(ctx, "**__```ùêÑùêëùêëùêé```__**", "- > **Personagem n√£o encontrado ou voc√™ n√£o tem permiss√£o para remov√™-lo.**", discord.Color.red())
        else:
            conn.commit()
            await send_embed(ctx, "**__```ùêèùêÑùêëùêíùêéùêçùêÄùêÜùêÑùêå ùêëùêÑùêåùêéùêïùêàùêÉùêé```__**", f'- > **Personagem __{name}__ removido com sucesso.**', discord.Color.green())

    @bot.command(name='details')
    async def details(ctx, *, name: str):
        c.execute("SELECT character_id, name, image_url, experience, level, points, forca, resistencia, agilidade, sentidos, vitalidade, inteligencia, rank, message_count, registered_at FROM characters WHERE name COLLATE NOCASE=? AND user_id=?", (name, ctx.author.id))
        character = c.fetchone()

        if not character:
            await send_embed(ctx, "**__```ùêÑùêëùêëùêé```__**", "- > **Personagem n√£o encontrado ou voc√™ n√£o tem permiss√£o para visualiz√°-lo.**", discord.Color.red())
            return

        character_id, name, image_url, experience, level, points, forca, resistencia, agilidade, sentidos, vitalidade, inteligencia, rank, message_count, registered_at = character

        c.execute("SELECT main_class, sub_class1, sub_class2 FROM characters_classes WHERE character_id=?", (character_id,))
        classes = c.fetchone()

        main_class = classes[0] if classes and classes[0] else "ùêçùêéùêçùêÑ"
        sub_class1 = classes[1] if classes and classes[1] else "ùêçùêéùêçùêÑ"
        sub_class2 = classes[2] if classes and classes[2] else "ùêçùêéùêçùêÑ"

        points_info = f"{points}" if points > 0 else "ùêçùêéùêçùêÑ"

        c.execute("SELECT rebirth_count FROM rebirths WHERE character_name=? AND user_id=?", (name, ctx.author.id))
        rebirth_data = c.fetchone()
        rebirth_count = rebirth_data[0] if rebirth_data else 0  

        
        description = (
            f"``` ùêàùêçùêÖùêéùêëùêåùêÄùêìùêàùêéùêç ```- ‚Äî ‚óá\n"
            f"> **__ùêçùêÄùêåùêÑ__**\n"
            f"‚óè *{name}*\n"
            f"> **__ùêãùêÑùêïùêÑùêã__**\n"
            f"‚óè *{level}*\n"
            f"> **__ùêÑùêóùêè__**\n"
            f"‚óã *{experience}/{xp_for_next_level(level)}*\n"
            f"> **__ùêÇùêãùêÄùêíùêí__**\n"
            f"‚óè *{main_class}*\n"
            f"> **__ùêíùêîùêÅùêÇùêãùêÄùêíùêí__**\n"
            f"‚óã *{sub_class1}, {sub_class2}*\n\n"
            f"- ‚Äî *[* **ùêèùêéùêàùêçùêìùêí: ** ` {points_info} ` *]* ‚Äî\n"
            f"‚óè ‚óã ***[*** `ùêëùêÄùêçùêä {rank}` ***]*** ‚óã ‚óè"
        )

        embed = discord.Embed(title="``` ùîªùîºùïãùî∏ùïÄùïÉùïä ```", description=description, color=discord.Color.dark_grey())
        if image_url:
            embed.set_image(url=image_url)

        button_status = Button(label="ùêíùêìùêÄùêìùêîùêí", style=discord.ButtonStyle.secondary, custom_id="show_status")
        button_inventory = Button(label="ùêàùêçùêïùêÑùêçùêìùêéùêëùêò", style=discord.ButtonStyle.secondary, custom_id="show_inventory")
        button_techniques = Button(label="ùêìùêÑùêÇùêáùêçùêàùêêùêîùêÑùêí", style=discord.ButtonStyle.secondary, custom_id="show_techniques")

        async def button_status_callback(interaction):
            if interaction.user.id != ctx.author.id:
                await interaction.response.send_message("- > **Voc√™ n√£o tem permiss√£o para ver os status deste personagem.**", ephemeral=True)
                return

            status_description = (
                f"# ‚Äî ‚Ä¢ ***[*** __ùêÄùêìùêìùêëùêàùêÅùêîùêìùêÑùêí__ ***]*** ‚Ä¢ ‚Äî\n"
                f"- ``` . . . ```\n"
                f"- ùêíùêìùêëùêÑùêçùêÜùêìùêá ***[*** ` {forca} ` ***]***\n"
                f"- ùêëùêÑùêíùêàùêíùêìùêÄùêçùêÇùêÑ ***[*** ` {resistencia} ` ***]***\n"
                f"- ùêÄùêÜùêàùêãùêàùêìùêò ***[*** ` {agilidade} ` ***]***\n"
                f"- ùêíùêÑùêçùêíùêÑùêí ***[*** ` {sentidos} ` ***]***\n"
                f"- ùêïùêàùêìùêÄùêãùêàùêìùêò ***[*** ` {vitalidade} ` ***]***\n"
                f"- ùêàùêçùêìùêÑùêãùêãùêàùêÜùêÑùêçùêÇùêÑ ***[*** ` {inteligencia} ` ***]***\n"
                f"- ùêèùêéùêàùêçùêìùêí ***[*** ` {points} ` ***]***\n"
                f"- ``` . . . ```\n"
                f"‚óè **__ùêëùêÑùêÅùêàùêëùêìùêáùêí__** ***[*** ` {rebirth_count} ` ***]***\n"
                f"- ``` . . . ```"
            )

            status_embed = discord.Embed(title="ùïäùïãùî∏ùïãùïåùïä", description=status_description, color=discord.Color.dark_grey())
            button_details = Button(label="ùêÉùêÑùêìùêÄùêàùêãùêí", style=discord.ButtonStyle.secondary, custom_id="show_details")

            async def button_details_callback(interaction):
                await interaction.response.edit_message(embed=embed, view=view)

            button_details.callback = button_details_callback
            status_view = View()
            status_view.add_item(button_details)
            await interaction.response.edit_message(embed=status_embed, view=status_view)

        async def button_inventory_callback(interaction):
            if interaction.user.id != ctx.author.id:
                await interaction.response.send_message("- > **Voc√™ n√£o tem permiss√£o para ver o invent√°rio deste personagem.**", ephemeral=True)
                return

            c.execute("SELECT item_name, description, image_url FROM inventory WHERE character_name COLLATE NOCASE=? AND user_id=?", (name, ctx.author.id))
            items = c.fetchall()
            per_page = 5
            total_pages = math.ceil(len(items) / per_page)
            current_page = 1

            async def update_inventory_message(interaction, page):
                if page < 1:
                    page = total_pages
                elif page > total_pages:
                    page = 1
                inventory_embed = await create_inventory_embed(items, page, per_page, total_pages, name)
                await interaction.response.edit_message(embed=inventory_embed, view=create_inventory_view(page))

            def create_inventory_view(page):
                view = View()
                buttons = [("‚è™", 1), ("‚óÄ", page - 1), ("ùêÉùêÑùêìùêÄùêàùêãùêí", None), ("‚ñ∂", page + 1), ("‚è©", total_pages)]
                for label, target_page in buttons:
                    button = Button(label=label, style=discord.ButtonStyle.secondary)
                    if target_page is not None:
                        button.callback = lambda interaction, tp=target_page: update_inventory_message(interaction, tp)
                    else:
                        button.callback = return_to_details
                    view.add_item(button)
                return view

            async def create_inventory_embed(items, page, per_page, total_pages, character_name):
                start = (page - 1) * per_page
                end = start + per_page
                item_list = items[start:end]

                formatted_name = to_bold_sans_serif(character_name)

                embed = discord.Embed(title=f"ùêàùêçùêïùêÑùêçùêìùêÄÃÅùêëùêàùêé ùêÉùêÑ {formatted_name} (p√°gina {page}/{total_pages})", color=discord.Color.dark_grey())

                description = "\n".join([
                    apply_layout(ctx.author.id, f"**{item_name}**", description)[0] + "\n" + apply_layout(ctx.author.id, f"**{item_name}**", description)[1]  
                    for item_name, description, image_url in item_list
                ])
                embed.description = description
                return embed

            async def return_to_details(interaction):
                await interaction.response.edit_message(embed=embed, view=view)

            inventory_embed = await create_inventory_embed(items, current_page, per_page, total_pages, name)
            await interaction.response.edit_message(embed=inventory_embed, view=create_inventory_view(current_page))


        async def button_techniques_callback(interaction):
            if interaction.user.id != ctx.author.id:
                await interaction.response.send_message("- > **Voc√™ n√£o tem permiss√£o para ver as t√©cnicas deste personagem.**", ephemeral=True)
                return

            c.execute("SELECT technique_name, description FROM techniques WHERE character_id=?", (character_id,))
            techniques = c.fetchall()
            per_page = 5
            total_pages = math.ceil(len(techniques) / per_page)
            current_page = 1

            async def update_techniques_message(interaction, page):
                if page < 1:
                    page = total_pages
                elif page > total_pages:
                    page = 1
                techniques_embed = await create_techniques_embed(techniques, page, per_page, total_pages, name)
                await interaction.response.edit_message(embed=techniques_embed, view=create_technique_view(page))

            def create_technique_view(page):
                view = View()
                buttons = [("‚è™", 1), ("‚óÄ", page - 1), ("ùêÉùêÑùêìùêÄùêàùêãùêí", None), ("‚ñ∂", page + 1), ("‚è©", total_pages)]
                for label, target_page in buttons:
                    button = Button(label=label, style=discord.ButtonStyle.secondary)
                    button.callback = lambda interaction, tp=target_page: update_techniques_message(interaction, tp) if tp else return_to_details(interaction)
                    view.add_item(button)
                return view

            async def create_techniques_embed(techniques, page, per_page, total_pages, character_name):
                start = (page - 1) * per_page
                end = start + per_page
                technique_list = techniques[start:end]

                formatted_name = to_bold_sans_serif(character_name)

                embed = discord.Embed(title=f"ùêìùêÑÃÅùêÇùêçùêàùêÇùêÄùêí ùêÉùêÑ {formatted_name} (p√°gina {page}/{total_pages})", color=discord.Color.dark_grey())

                description = "\n".join([
                    apply_layout(ctx.author.id, f"{technique_name}", description)[0] + "\n" + apply_layout(ctx.author.id, f"{technique_name}", description)[1]  
                    for technique_name, description in technique_list
                ])
                embed.description = description
                return embed

            async def return_to_details(interaction):
                await interaction.response.edit_message(embed=embed, view=view)

            techniques_embed = await create_techniques_embed(techniques, current_page, per_page, total_pages, name)
            await interaction.response.edit_message(embed=techniques_embed, view=create_technique_view(current_page))

        button_status.callback = button_status_callback
        button_inventory.callback = button_inventory_callback
        button_techniques.callback = button_techniques_callback

        view = View()
        view.add_item(button_status)
        view.add_item(button_inventory)
        view.add_item(button_techniques)

        await ctx.send(embed=embed, view=view)

    @bot.command(name='avatar')
    async def avatar(ctx, *, name: str):
        c.execute("SELECT image_url, message_id FROM characters WHERE name COLLATE NOCASE=? AND user_id=?", (name, ctx.author.id))
        character = c.fetchone()
        if not character:
            await send_embed(ctx, "**__```ùêÑùêëùêëùêé```__**", "- > **Personagem n√£o encontrado ou voc√™ n√£o tem permiss√£o para visualizar ou atualizar o avatar.**", discord.Color.red())
        else:
            if ctx.message.attachments:
                image_url = ctx.message.attachments[0].url
                message_id = ctx.message.id
                c.execute("UPDATE characters SET image_url=?, message_id=? WHERE name COLLATE NOCASE=? AND user_id=?", (image_url, message_id, name, ctx.author.id))
                conn.commit()
                await send_embed(ctx, "**__```ùêÄùêïùêÄùêìùêÄùêë ùêÄùêìùêîùêÄùêãùêàùêôùêÄùêÉùêé!!!```__**", f"- > **Avatar do personagem __{name}__ atualizado com sucesso.**", discord.Color.green(), image_url)
            else:
                image_url, message_id = character
                if image_url:
                    try:
                        original_message = await ctx.channel.fetch_message(message_id)
                        if original_message:
                            await send_embed(ctx, f"**__```ùêÄùêïùêÄùêìùêÄùêë```__**", "", discord.Color.blue(), image_url)
                    except discord.errors.NotFound:
                        c.execute("UPDATE characters SET image_url=NULL, message_id=NULL WHERE name COLLATE NOCASE=? AND user_id=?", (name, ctx.author.id))
                        conn.commit()
                        await send_embed(ctx, "**__```ùêÑùêëùêëùêé```__**", f"- > **Nenhum avatar definido para o personagem {name}. Para definir um avatar, forne√ßa um link direto para a imagem ou fa√ßa o upload como um anexo ao executar este comando.**", discord.Color.red())
                else:
                    await send_embed(ctx, "**__```ùêÑùêëùêëùêé```__**", f"- > **Nenhum avatar definido para o personagem {name}. Para definir um avatar, forne√ßa um link direto para a imagem ou fa√ßa o upload como um anexo ao executar este comando.**", discord.Color.red())

    @bot.command(name='rename')
    async def rename(ctx, *, args: str):
        match = re.match(r"'(.+?)'\s*'(.+?)'", args)
        if not match:
            await send_embed(
                ctx,
                "**__```ùêÖùêéùêëùêåùêÄùêìùêé ùêàùêçùêïùêÄÃÅùêãùêàùêÉùêé```__**",
                "- > **Use: kill!rename 'Nome Antigo' 'Nome Novo'**",
                discord.Color.red()
            )
            return

        old_name, new_name = match.groups()

        c.execute("SELECT 1 FROM characters WHERE name=? AND user_id=?", (new_name, ctx.author.id))
        existing_character = c.fetchone()

        if existing_character and old_name.lower() != new_name.lower():
            await send_embed(
                ctx,
                "**__```ùêçùêéùêåùêÑ ùêÑùêå ùêîùêíùêé```__**",
                "- > **O nome j√° est√° em uso.**",
                discord.Color.red()
            )
            return

        c.execute("UPDATE characters SET name=? WHERE name=? AND user_id=?", (new_name, old_name, ctx.author.id))
        if c.rowcount == 0:
            await send_embed(
                ctx,
                "**__```ùêÑùêëùêëùêé```__**",
                '- > **Personagem n√£o encontrado ou voc√™ n√£o tem permiss√£o para renome√°-lo.**',
                discord.Color.red()
            )
        else:
            conn.commit()
            await send_embed(
                ctx,
                "**__```ùêèùêÑùêëùêíùêéùêçùêÄùêÜùêÑùêå ùêëùêÑùêçùêéùêåùêÑùêÄùêÉùêé```__**",
                f'- > **Personagem __{old_name}__ renomeado para __{new_name}__ com sucesso.**',
                discord.Color.green()
            )

    @bot.command(name='list')
    async def list_characters(ctx, member: discord.Member = None):
        user_id = member.id if member else ctx.author.id
        display_name = member.display_name if member else ctx.author.display_name

        c.execute("SELECT private FROM characters WHERE user_id=? LIMIT 1", (user_id,))
        private_status = c.fetchone()
        if private_status and private_status[0] == 1 and ctx.author.id != user_id:
            await send_embed(ctx, "**__```ùêÄùêÇùêÑùêíùêíùêé ùêçùêÑùêÜùêÄùêÉùêé```__**", "- > **Os personagens deste usu√°rio s√£o privados.**", discord.Color.red())
            return

        c.execute("SELECT name, image_url, message_count, registered_at FROM characters WHERE user_id=?", (user_id,))
        characters = c.fetchall()
        if not characters:
            await send_embed(ctx, "**__```ùêçùêÑùêçùêáùêîùêå ùêèùêÑùêëùêíùêéùêçùêÄùêÜùêÑùêå ùêÑùêçùêÇùêéùêçùêìùêëùêÄùêÉùêé```__**", "- > **Nenhum personagem registrado.**", discord.Color.red())
            return

        per_page = 5
        total_results = len(characters)
        total_pages = math.ceil(total_results / per_page)
        current_page = 1

        async def update_message(interaction, page):
            if page < 1:
                page = total_pages
            elif page > total_pages:
                page = 1
            embed = await create_list_embed(characters, page, per_page, total_pages, total_results, display_name)
            await interaction.response.edit_message(embed=embed, view=create_list_view(page))

        def create_list_view(page):
            view = View()
            buttons = [
                ("‚è™", 1), ("‚óÄ", page - 1), (". . .", None), ("‚ñ∂", page + 1), ("‚è©", total_pages)
            ]
            for label, target_page in buttons:
                button = Button(label=label, style=discord.ButtonStyle.secondary)
                if target_page is not None:
                    button.callback = lambda interaction, tp=target_page: update_message(interaction, tp)
                else:
                    button.callback = create_page_modal
                view.add_item(button)
            return view

        async def create_page_modal(interaction):
            if interaction.user != ctx.author:
                await interaction.response.send_message("- > **Voc√™ n√£o pode usar este comando.**", ephemeral=True)
                return

            modal = GoToPageModal(update_message, total_pages)
            await interaction.response.send_modal(modal)

        embed = await create_list_embed(characters, current_page, per_page, total_pages, total_results, display_name)
        await ctx.send(embed=embed, view=create_list_view(current_page))
    
    async def create_list_embed(characters, page, per_page, total_pages, total_results, display_name):
        start = (page - 1) * per_page
        end = start + per_page
        formatted_name = to_bold_sans_serif(display_name)
        embed = discord.Embed(title=f"{display_name}'ùêí ùêëùêÑùêÜùêàùêíùêìùêÑùêëùêÑùêÉ ùêÇùêáùêÄùêëùêÄùêÇùêìùêÑùêëùêí (ùêèùêÄùêÜùêÑ {page}/{total_pages})", color=discord.Color.dark_grey())
        result_list = [
            f"**{name}**\n[ùêÄùêïùêÄùêìùêÄùêë]({image_url if image_url else 'ùêçùêé ùêÄùêïùêÄùêìùêÄùêë'})\nùêìùêéùêìùêÄùêã ùêåùêÑùêíùêíùêÄùêÜùêÑùêí ùêíùêÑùêçùêì: {message_count}\nùêëùêÑùêÜùêàùêíùêìùêÑùêëùêÑùêÉ: {registered_at}\n"
            for name, image_url, message_count, registered_at in characters[start:end]
        ]
        embed.description = "\n".join(result_list)
        embed.set_footer(text=f"ùêèùêÄùêÜùêÑ {page}/{total_pages} ‚Ä¢ ùêìùêéùêìùêÄùêã ùêÇùêáùêÄùêëùêÄùêÇùêìùêÑùêëùêí: {total_results}")
        return embed

    class GoToPageModal(Modal):
        def __init__(self, update_message, total_pages):
            super().__init__(title="ùêÜùêé ùêìùêé ùêèùêÄùêÜùêÑ")
            self.update_message = update_message
            self.total_pages = total_pages
            self.page_number = TextInput(label="ùêèùêÄùêÜùêÑ ùêçùêîùêåùêÅùêÑùêë", style=discord.TextStyle.short)
            self.add_item(self.page_number)

        async def on_submit(self, interaction):
            try:
                page = int(self.page_number.value)
                if 1 <= page <= self.total_pages:
                    await self.update_message(interaction, page)
                else:
                    await interaction.response.send_message(f"Invalid page number. Please enter a number between 1 and {self.total_pages}.", ephemeral=True)
            except ValueError:
                await interaction.response.send_message("Invalid page number. Please enter a valid integer.", ephemeral=True)
